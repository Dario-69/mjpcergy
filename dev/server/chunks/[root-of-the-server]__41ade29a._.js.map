{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/dariusoccansey/Workspace/Matrix/mjp-training-app/src/lib/mongodb.ts"],"sourcesContent":["import mongoose from 'mongoose';\n\nconst MONGODB_URI = process.env.MONGODB_URI!;\n\nif (!MONGODB_URI) {\n  throw new Error('Please define the MONGODB_URI environment variable inside .env.local');\n}\n\n/**\n * Global is used here to maintain a cached connection across hot reloads\n * in development. This prevents connections growing exponentially\n * during API Route usage.\n */\nlet cached = global.mongoose;\n\nif (!cached) {\n  cached = global.mongoose = { conn: null, promise: null };\n}\n\nasync function connectDB() {\n  if (cached.conn) {\n    return cached.conn;\n  }\n\n  if (!cached.promise) {\n    const opts = {\n      bufferCommands: false,\n    };\n\n    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {\n      return mongoose;\n    });\n  }\n\n  try {\n    cached.conn = await cached.promise;\n  } catch (e) {\n    cached.promise = null;\n    throw e;\n  }\n\n  return cached.conn;\n}\n\nexport default connectDB;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW;AAE3C,IAAI,CAAC,aAAa;IAChB,MAAM,IAAI,MAAM;AAClB;AAEA;;;;CAIC,GACD,IAAI,SAAS,yDAAO,QAAQ;AAE5B,IAAI,CAAC,QAAQ;IACX,SAAS,yDAAO,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AACzD;AAEA,eAAe;IACb,IAAI,OAAO,IAAI,EAAE;QACf,OAAO,OAAO,IAAI;IACpB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,OAAO;YACX,gBAAgB;QAClB;QAEA,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,aAAa,MAAM,IAAI,CAAC,CAAC;YACzD,OAAO;QACT;IACF;IAEA,IAAI;QACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IACpC,EAAE,OAAO,GAAG;QACV,OAAO,OAAO,GAAG;QACjB,MAAM;IACR;IAEA,OAAO,OAAO,IAAI;AACpB;uCAEe","debugId":null}},
    {"offset": {"line": 104, "column": 0}, "map": {"version":3,"sources":["file:///Users/dariusoccansey/Workspace/Matrix/mjp-training-app/src/lib/video-storage.ts"],"sourcesContent":["import { GridFSBucket, ObjectId } from 'mongodb';\nimport connectDB from './mongodb';\n\nexport class VideoStorageService {\n  private static instance: VideoStorageService;\n  private bucket: GridFSBucket | null = null;\n\n  private constructor() {}\n\n  public static getInstance(): VideoStorageService {\n    if (!VideoStorageService.instance) {\n      VideoStorageService.instance = new VideoStorageService();\n    }\n    return VideoStorageService.instance;\n  }\n\n  private async getBucket(): Promise<GridFSBucket> {\n    if (!this.bucket) {\n      const db = await connectDB();\n      this.bucket = new GridFSBucket(db, { bucketName: 'videos' });\n    }\n    return this.bucket;\n  }\n\n  /**\n   * Upload une vidéo vers GridFS\n   */\n  async uploadVideo(\n    file: Buffer, \n    filename: string, \n    metadata: {\n      title: string;\n      description?: string;\n      uploadedBy: string;\n      department?: string;\n    }\n  ): Promise<string> {\n    try {\n      const bucket = await this.getBucket();\n      \n      // Générer un nom de fichier unique\n      const fileId = new ObjectId();\n      const fileExtension = filename.split('.').pop();\n      const gridFSFilename = `${fileId.toString()}.${fileExtension}`;\n\n      // Upload vers GridFS\n      const uploadStream = bucket.openUploadStream(gridFSFilename, {\n        metadata: {\n          ...metadata,\n          originalFilename: filename,\n          uploadedAt: new Date(),\n        }\n      });\n\n      return new Promise((resolve, reject) => {\n        uploadStream.end(file);\n        \n        uploadStream.on('finish', () => {\n          resolve(fileId.toString());\n        });\n        \n        uploadStream.on('error', (error) => {\n          reject(error);\n        });\n      });\n    } catch (error) {\n      console.error('Erreur lors de l\\'upload vers GridFS:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Récupère une vidéo depuis GridFS\n   */\n  async getVideo(videoId: string): Promise<{\n    stream: NodeJS.ReadableStream;\n    metadata: any;\n  }> {\n    try {\n      const bucket = await this.getBucket();\n      const objectId = new ObjectId(videoId);\n      \n      // Vérifier que le fichier existe\n      const files = await bucket.find({ _id: objectId }).toArray();\n      if (files.length === 0) {\n        throw new Error('Vidéo non trouvée');\n      }\n\n      const downloadStream = bucket.openDownloadStream(objectId);\n      const metadata = files[0];\n\n      return {\n        stream: downloadStream,\n        metadata\n      };\n    } catch (error) {\n      console.error('Erreur lors de la récupération de la vidéo:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Supprime une vidéo de GridFS\n   */\n  async deleteVideo(videoId: string): Promise<void> {\n    try {\n      const bucket = await this.getBucket();\n      const objectId = new ObjectId(videoId);\n      \n      await bucket.delete(objectId);\n    } catch (error) {\n      console.error('Erreur lors de la suppression de la vidéo:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Récupère les métadonnées d'une vidéo\n   */\n  async getVideoMetadata(videoId: string): Promise<any> {\n    try {\n      const bucket = await this.getBucket();\n      const objectId = new ObjectId(videoId);\n      \n      const files = await bucket.find({ _id: objectId }).toArray();\n      if (files.length === 0) {\n        throw new Error('Vidéo non trouvée');\n      }\n\n      return files[0];\n    } catch (error) {\n      console.error('Erreur lors de la récupération des métadonnées:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Liste toutes les vidéos d'un utilisateur\n   */\n  async getUserVideos(userId: string): Promise<any[]> {\n    try {\n      const bucket = await this.getBucket();\n      \n      const files = await bucket.find({ \n        'metadata.uploadedBy': userId \n      }).toArray();\n\n      return files;\n    } catch (error) {\n      console.error('Erreur lors de la récupération des vidéos utilisateur:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Vérifie si un fichier vidéo existe\n   */\n  async videoExists(videoId: string): Promise<boolean> {\n    try {\n      const bucket = await this.getBucket();\n      const objectId = new ObjectId(videoId);\n      \n      const files = await bucket.find({ _id: objectId }).toArray();\n      return files.length > 0;\n    } catch (error) {\n      return false;\n    }\n  }\n}\n\nexport const videoStorageService = VideoStorageService.getInstance();\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":["file:///Users/dariusoccansey/Workspace/Matrix/mjp-training-app/src/app/api/videos/upload/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { videoStorageService } from \"@/lib/video-storage\";\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const file = formData.get('file') as File;\n    const title = formData.get('title') as string;\n    const description = formData.get('description') as string;\n    const uploadedBy = formData.get('uploadedBy') as string;\n    const department = formData.get('department') as string;\n\n    if (!file || !title || !uploadedBy) {\n      return NextResponse.json(\n        { message: \"Fichier, titre et utilisateur requis\" },\n        { status: 400 }\n      );\n    }\n\n    // Vérifier le type de fichier\n    if (!file.type.startsWith('video/')) {\n      return NextResponse.json(\n        { message: \"Le fichier doit être une vidéo\" },\n        { status: 400 }\n      );\n    }\n\n    // Vérifier la taille (limite de 100MB pour GridFS)\n    const maxSize = 100 * 1024 * 1024; // 100MB\n    if (file.size > maxSize) {\n      return NextResponse.json(\n        { message: \"Le fichier est trop volumineux. Taille maximale : 100MB\" },\n        { status: 400 }\n      );\n    }\n\n    // Convertir le fichier en buffer\n    const buffer = Buffer.from(await file.arrayBuffer());\n\n    // Upload vers GridFS\n    const videoId = await videoStorageService.uploadVideo(\n      buffer,\n      file.name,\n      {\n        title,\n        description: description || '',\n        uploadedBy,\n        department: department || undefined,\n      }\n    );\n\n    return NextResponse.json({\n      success: true,\n      videoId,\n      filename: file.name,\n      size: file.size,\n      type: file.type\n    });\n\n  } catch (error) {\n    console.error(\"Erreur lors de l'upload:\", error);\n    return NextResponse.json(\n      { message: \"Erreur lors de l'upload de la vidéo\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAC1B,MAAM,QAAQ,SAAS,GAAG,CAAC;QAC3B,MAAM,cAAc,SAAS,GAAG,CAAC;QACjC,MAAM,aAAa,SAAS,GAAG,CAAC;QAChC,MAAM,aAAa,SAAS,GAAG,CAAC;QAEhC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY;YAClC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;YAAuC,GAClD;gBAAE,QAAQ;YAAI;QAElB;QAEA,8BAA8B;QAC9B,IAAI,CAAC,KAAK,IAAI,CAAC,UAAU,CAAC,WAAW;YACnC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;YAAiC,GAC5C;gBAAE,QAAQ;YAAI;QAElB;QAEA,mDAAmD;QACnD,MAAM,UAAU,MAAM,OAAO,MAAM,QAAQ;QAC3C,IAAI,KAAK,IAAI,GAAG,SAAS;YACvB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;YAA0D,GACrE;gBAAE,QAAQ;YAAI;QAElB;QAEA,iCAAiC;QACjC,MAAM,SAAS,OAAO,IAAI,CAAC,MAAM,KAAK,WAAW;QAEjD,qBAAqB;QACrB,MAAM,UAAU,MAAM,uJAAmB,CAAC,WAAW,CACnD,QACA,KAAK,IAAI,EACT;YACE;YACA,aAAa,eAAe;YAC5B;YACA,YAAY,cAAc;QAC5B;QAGF,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA,UAAU,KAAK,IAAI;YACnB,MAAM,KAAK,IAAI;YACf,MAAM,KAAK,IAAI;QACjB;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;QAAsC,GACjD;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}