{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/dariusoccansey/Workspace/Matrix/mjp-training-app/src/lib/video-storage.ts"],"sourcesContent":["import { MongoClient, GridFSBucket, ObjectId } from 'mongodb';\n\nexport class VideoStorageService {\n  private static instance: VideoStorageService;\n  private client: MongoClient | null = null;\n  private db: any = null;\n  private bucket: GridFSBucket | null = null;\n\n  private constructor() {}\n\n  public static getInstance(): VideoStorageService {\n    if (!VideoStorageService.instance) {\n      VideoStorageService.instance = new VideoStorageService();\n    }\n    return VideoStorageService.instance;\n  }\n\n  private async connectDB() {\n    if (this.db && this.client && this.client.isConnected()) {\n      return;\n    }\n    \n    if (!process.env.MONGODB_URI) {\n      throw new Error('MONGODB_URI is not defined in environment variables');\n    }\n    \n    try {\n      // Créer une nouvelle connexion MongoDB\n      this.client = new MongoClient(process.env.MONGODB_URI, {\n        maxPoolSize: 10,\n        serverSelectionTimeoutMS: 5000,\n        socketTimeoutMS: 45000,\n        tls: true,\n        tlsAllowInvalidCertificates: true,\n        tlsAllowInvalidHostnames: true,\n      });\n      \n      await this.client.connect();\n      this.db = this.client.db();\n      this.bucket = new GridFSBucket(this.db, { bucketName: 'videos' });\n      \n      console.log('✅ Connexion MongoDB réussie pour GridFS');\n    } catch (error) {\n      console.error('❌ Erreur de connexion MongoDB:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Upload une vidéo vers GridFS\n   */\n  async uploadVideo(\n    file: Buffer, \n    filename: string, \n    metadata: {\n      title: string;\n      description?: string;\n      uploadedBy: string;\n      department?: string;\n    }\n  ): Promise<string> {\n    try {\n      await this.connectDB();\n      \n      if (!this.bucket) {\n        throw new Error('GridFSBucket not initialized');\n      }\n      \n      // Générer un nom de fichier unique\n      const fileId = new ObjectId();\n      const fileExtension = filename.split('.').pop();\n      const gridFSFilename = `${fileId.toString()}.${fileExtension}`;\n\n      // Upload vers GridFS\n      const uploadStream = this.bucket.openUploadStream(gridFSFilename, {\n        metadata: {\n          ...metadata,\n          originalFilename: filename,\n          uploadedAt: new Date(),\n        }\n      });\n\n      return new Promise((resolve, reject) => {\n        uploadStream.end(file);\n        \n        uploadStream.on('finish', () => {\n          resolve(fileId.toString());\n        });\n        \n        uploadStream.on('error', (error) => {\n          reject(error);\n        });\n      });\n    } catch (error) {\n      console.error('Erreur lors de l\\'upload vers GridFS:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Récupère une vidéo depuis GridFS\n   */\n  async getVideo(videoId: string): Promise<{\n    stream: NodeJS.ReadableStream;\n    metadata: any;\n  }> {\n    try {\n      await this.connectDB();\n      \n      if (!this.bucket || !this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const objectId = new ObjectId(videoId);\n      \n      // Vérifier que le fichier existe\n      const files = await this.db.collection('videos.files').find({ _id: objectId }).toArray();\n      if (files.length === 0) {\n        throw new Error('Vidéo non trouvée');\n      }\n\n      const downloadStream = this.bucket.openDownloadStream(objectId);\n      const metadata = files[0];\n\n      return {\n        stream: downloadStream,\n        metadata\n      };\n    } catch (error) {\n      console.error('Erreur lors de la récupération de la vidéo:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Supprime une vidéo de GridFS\n   */\n  async deleteVideo(videoId: string): Promise<void> {\n    try {\n      const bucket = await this.getBucket();\n      const objectId = new ObjectId(videoId);\n      \n      await bucket.delete(objectId);\n    } catch (error) {\n      console.error('Erreur lors de la suppression de la vidéo:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Récupère les métadonnées d'une vidéo\n   */\n  async getVideoMetadata(videoId: string): Promise<any> {\n    try {\n      const bucket = await this.getBucket();\n      const objectId = new ObjectId(videoId);\n      \n      const files = await bucket.find({ _id: objectId }).toArray();\n      if (files.length === 0) {\n        throw new Error('Vidéo non trouvée');\n      }\n\n      return files[0];\n    } catch (error) {\n      console.error('Erreur lors de la récupération des métadonnées:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Liste toutes les vidéos d'un utilisateur\n   */\n  async getUserVideos(userId: string): Promise<any[]> {\n    try {\n      const bucket = await this.getBucket();\n      \n      const files = await bucket.find({ \n        'metadata.uploadedBy': userId \n      }).toArray();\n\n      return files;\n    } catch (error) {\n      console.error('Erreur lors de la récupération des vidéos utilisateur:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Vérifie si un fichier vidéo existe\n   */\n  async videoExists(videoId: string): Promise<boolean> {\n    try {\n      const bucket = await this.getBucket();\n      const objectId = new ObjectId(videoId);\n      \n      const files = await bucket.find({ _id: objectId }).toArray();\n      return files.length > 0;\n    } catch (error) {\n      return false;\n    }\n  }\n}\n\nexport const videoStorageService = VideoStorageService.getInstance();\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":["file:///Users/dariusoccansey/Workspace/Matrix/mjp-training-app/src/app/api/videos/upload/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { videoStorageService } from \"@/lib/video-storage\";\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const file = formData.get('file') as File;\n    const title = formData.get('title') as string;\n    const description = formData.get('description') as string;\n    const uploadedBy = formData.get('uploadedBy') as string;\n    const department = formData.get('department') as string;\n\n    if (!file || !title || !uploadedBy) {\n      return NextResponse.json(\n        { message: \"Fichier, titre et utilisateur requis\" },\n        { status: 400 }\n      );\n    }\n\n    // Vérifier le type de fichier\n    if (!file.type.startsWith('video/')) {\n      return NextResponse.json(\n        { message: \"Le fichier doit être une vidéo\" },\n        { status: 400 }\n      );\n    }\n\n    // Vérifier la taille (limite de 100MB pour GridFS)\n    const maxSize = 100 * 1024 * 1024; // 100MB\n    if (file.size > maxSize) {\n      return NextResponse.json(\n        { message: \"Le fichier est trop volumineux. Taille maximale : 100MB\" },\n        { status: 400 }\n      );\n    }\n\n    // Convertir le fichier en buffer\n    const buffer = Buffer.from(await file.arrayBuffer());\n\n    // Upload vers GridFS\n    const videoId = await videoStorageService.uploadVideo(\n      buffer,\n      file.name,\n      {\n        title,\n        description: description || '',\n        uploadedBy,\n        department: department || undefined,\n      }\n    );\n\n    return NextResponse.json({\n      success: true,\n      videoId,\n      filename: file.name,\n      size: file.size,\n      type: file.type\n    });\n\n  } catch (error) {\n    console.error(\"Erreur lors de l'upload:\", error);\n    return NextResponse.json(\n      { message: \"Erreur lors de l'upload de la vidéo\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAC1B,MAAM,QAAQ,SAAS,GAAG,CAAC;QAC3B,MAAM,cAAc,SAAS,GAAG,CAAC;QACjC,MAAM,aAAa,SAAS,GAAG,CAAC;QAChC,MAAM,aAAa,SAAS,GAAG,CAAC;QAEhC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY;YAClC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;YAAuC,GAClD;gBAAE,QAAQ;YAAI;QAElB;QAEA,8BAA8B;QAC9B,IAAI,CAAC,KAAK,IAAI,CAAC,UAAU,CAAC,WAAW;YACnC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;YAAiC,GAC5C;gBAAE,QAAQ;YAAI;QAElB;QAEA,mDAAmD;QACnD,MAAM,UAAU,MAAM,OAAO,MAAM,QAAQ;QAC3C,IAAI,KAAK,IAAI,GAAG,SAAS;YACvB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;YAA0D,GACrE;gBAAE,QAAQ;YAAI;QAElB;QAEA,iCAAiC;QACjC,MAAM,SAAS,OAAO,IAAI,CAAC,MAAM,KAAK,WAAW;QAEjD,qBAAqB;QACrB,MAAM,UAAU,MAAM,uJAAmB,CAAC,WAAW,CACnD,QACA,KAAK,IAAI,EACT;YACE;YACA,aAAa,eAAe;YAC5B;YACA,YAAY,cAAc;QAC5B;QAGF,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA,UAAU,KAAK,IAAI;YACnB,MAAM,KAAK,IAAI;YACf,MAAM,KAAK,IAAI;QACjB;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;QAAsC,GACjD;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}